/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"fmt"
	"log"
	"net/http"
	_ "os"
	"path/filepath"
	"runtime"
	"time"

	"github.com/gin-gonic/gin"

	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	clusterctlv1 "sigs.k8s.io/cluster-api/cmd/clusterctl/api/v1alpha3"
	"sigs.k8s.io/cluster-api/cmd/clusterctl/client"
	"sigs.k8s.io/cluster-api/cmd/clusterctl/client/config"
)

const (
	httpaddress = ":8080"
	apiversion  = "0.1"
)

type Version struct {
	ClientVersion *Info `json:"clusterctl"`
}

type Components interface {
	// Provider holds configuration of the provider the provider components belong to.
	config.Provider

	// Version of the provider.
	Version() string

	// Variables required by the provider components.
	// This value is derived by the component YAML.
	Variables() []string

	// Images required to install the provider components.
	// This value is derived by the component YAML.
	Images() []string

	// TargetNamespace where the provider components will be installed.
	// By default this value is derived by the component YAML, but it is possible to override it
	// during the creation of the Components object.
	TargetNamespace() string

	// InventoryObject returns the clusterctl inventory object representing the provider that will be
	// generated by this components.
	InventoryObject() clusterctlv1.Provider

	// Yaml return the provider components in the form of a YAML file.
	Yaml() ([]byte, error)

	// Objs return the components in the form of a list of Unstructured objects.
	Objs() []unstructured.Unstructured
}

type Info struct {
	Major        string `json:"major,omitempty"`
	Minor        string `json:"minor,omitempty"`
	GitVersion   string `json:"gitVersion,omitempty"`
	GitCommit    string `json:"gitCommit,omitempty"`
	GitTreeState string `json:"gitTreeState,omitempty"`
	BuildDate    string `json:"buildDate,omitempty"`
	GoVersion    string `json:"goVersion,omitempty"`
	Compiler     string `json:"compiler,omitempty"`
	Platform     string `json:"platform,omitempty"`
}

type initOptions struct {
	kubeconfig              string
	kubeconfigContext       string
	coreProvider            string
	bootstrapProviders      []string
	controlPlaneProviders   []string
	infrastructureProviders []string
	targetNamespace         string
	listImages              bool
	waitProviders           bool
	waitProviderTimeout     int
}

type deleteOptions struct {
	kubeconfig              string
	kubeconfigContext       string
	coreProvider            string
	bootstrapProviders      []string
	controlPlaneProviders   []string
	infrastructureProviders []string
	includeNamespace        bool
	includeCRDs             bool
	deleteAll               bool
}

var initOpts = &initOptions{
	kubeconfig:              "",
	kubeconfigContext:       "",
	coreProvider:            "",
	bootstrapProviders:      nil,
	controlPlaneProviders:   nil,
	infrastructureProviders: []string{config.BYOHProviderName},
	targetNamespace:         "",
	listImages:              false,
	waitProviders:           false,
	waitProviderTimeout:     5 * 60,
}

var deleteOpts = &deleteOptions{
	kubeconfig:              "",
	kubeconfigContext:       "",
	coreProvider:            "",
	bootstrapProviders:      nil,
	controlPlaneProviders:   nil,
	infrastructureProviders: []string{config.BYOHProviderName},
	includeNamespace:        true,
	includeCRDs:             true,
	deleteAll:               true,
}

func int32Ptr(i int32) *int32 {
	return &i
}

func Get() Info {
	return Info{
		GoVersion: runtime.Version(),
		Compiler:  runtime.Compiler,
		Platform:  fmt.Sprintf("%s/%s", runtime.GOOS, runtime.GOARCH),
	}
}

func getApi(cr *gin.Context) {

	log.Println("getAPI request received")

	//CORS
	cr.Writer.Header().Set("Access-Control-Allow-Origin", "*")
	cr.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
	cr.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
	cr.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT")

	/*clientVersion := Get()
	v := Version{
		ClientVersion: &clientVersion,
	}*/

	cr.JSON(http.StatusOK, gin.H{
		"Name":        "APIGW",
		"Version":     apiversion,
		"GoVersion":   runtime.Version(),
		"Compiler":    runtime.Compiler,
		"Platform":    fmt.Sprintf("%s/%s", runtime.GOOS, runtime.GOARCH),
		"CAPIVersion": "",
		"Date":        time.Now().String(),
	})
}

func getRepositories(cr *gin.Context) {

	log.Println("getRepositories request received")

	//CORS
	cr.Writer.Header().Set("Access-Control-Allow-Origin", "*")
	cr.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
	cr.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
	cr.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT")

	c, err := client.New("")
	if err != nil {
		cr.String(http.StatusNotFound, "Error: %s", err.Error())
		return
	}
	repositoryList, err := c.GetProvidersConfig()
	if err != nil {
		cr.String(http.StatusNotFound, "Error: %s", err.Error())
		return
	}

	s := "["
	for _, r := range repositoryList {
		dir, file := filepath.Split(r.URL())
		s = s + fmt.Sprintf(`{ "name": "%s", "type": "%s", "url": "%s", "file": "%s" },`, r.Name(), r.Type(), dir, file)
	}
	s = s + "]"

	jsonData := []byte(s)

	cr.Data(http.StatusOK, "application/json", jsonData)
}

func initCapi(cr *gin.Context) {

	log.Println("initCAPI request received")

	//CORS
	cr.Writer.Header().Set("Access-Control-Allow-Origin", "*")
	cr.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
	cr.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
	cr.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT")

	c, err := client.New("")
	if err != nil {
		cr.String(http.StatusNotFound, "Error: %s", err.Error())
		return
	}

	options := client.InitOptions{
		Kubeconfig:              client.Kubeconfig{Path: initOpts.kubeconfig, Context: initOpts.kubeconfigContext},
		CoreProvider:            initOpts.coreProvider,
		BootstrapProviders:      initOpts.bootstrapProviders,
		ControlPlaneProviders:   initOpts.controlPlaneProviders,
		InfrastructureProviders: initOpts.infrastructureProviders,
		TargetNamespace:         initOpts.targetNamespace,
		LogUsageInstructions:    true,
		WaitProviders:           initOpts.waitProviders,
		WaitProviderTimeout:     time.Duration(initOpts.waitProviderTimeout) * time.Second,
	}

	if initOpts.listImages {
		images, err := c.InitImages(options)
		if err != nil {
			cr.String(http.StatusNotFound, "Error: %s", err.Error())
			return
		}

		for _, i := range images {
			fmt.Println(i)
		}
		return
	}

	if _, err := c.Init(options); err != nil {
		cr.String(http.StatusNotFound, "Error: %s", err.Error())
		return
	}

	cr.String(http.StatusOK, "Init OK")

}

func deleteCapi(cr *gin.Context) {

	log.Println("deleteCAPI request received")

	//CORS
	cr.Writer.Header().Set("Access-Control-Allow-Origin", "*")
	cr.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
	cr.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
	cr.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT")

	c, err := client.New("")
	if err != nil {
		cr.String(http.StatusNotFound, "Error: %s", err.Error())
		return
	}

	options := client.DeleteOptions{
		Kubeconfig:              client.Kubeconfig{Path: deleteOpts.kubeconfig, Context: deleteOpts.kubeconfigContext},
		IncludeNamespace:        deleteOpts.includeNamespace,
		IncludeCRDs:             deleteOpts.includeCRDs,
		CoreProvider:            deleteOpts.coreProvider,
		BootstrapProviders:      deleteOpts.bootstrapProviders,
		InfrastructureProviders: deleteOpts.infrastructureProviders,
		ControlPlaneProviders:   deleteOpts.controlPlaneProviders,
		DeleteAll:               deleteOpts.deleteAll,
	}

	if err := c.Delete(options); err != nil {
		cr.String(http.StatusNotFound, "Error: %s", err.Error())
		return
	}

	cr.JSON(http.StatusOK, "Delete OK")
}

func main() {
	//cmd.Execute()
	gin.SetMode(gin.ReleaseMode)
	router := gin.Default()

	v1 := router.Group("/")
	{
		v1.GET("/api", getApi)
		v1.GET("/repositories", getRepositories)
		v1.GET("/initcapi", initCapi)
		v1.GET("/deletecapi", deleteCapi)
	}

	log.Println("APIGW running on", httpaddress)
	router.Run(httpaddress)
}
